/* eslint-disable no-unused-vars */
/* eslint-disable react/prop-types */
import { Box, Autocomplete, TextField, IconButton, Typography, Checkbox, FormControlLabel } from '@mui/material';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import DeleteIcon from '@mui/icons-material/Delete';
import { useEffect, useState } from 'react';

const Union = ({ unions, components, onUnionChange, helperText, setErrors, expressionIndex }) => {
  const [componentOptions, setComponentOptions] = useState([]);
  const [generateInOrder, setGenerateInOrder] = useState(false);
  const [autoGeneratedUnionType, setAutoGeneratedUnionType] = useState('Order');
  const unionTypeOptions = ["Order", "Regulate"];

  useEffect(() => {
    const options = components.flatMap((component) => {
      return component.instance_id ? `${component.name} [${component.instance_id}]` : component.name;
    });
    setComponentOptions(options);
  }, [components]);

  useEffect(() => {
    if (!generateInOrder) {
      const currentUnionsForComparison = unions.map(u => ({
        fromName: u.from.name, fromInstanceId: u.from.instance_id,
        toName: u.to.name, toInstanceId: u.to.instance_id,
        type: u.type,
      }));

      const updatedUnions = unions.map(union => {
        const fromExists = componentOptions.includes(
          union.from.instance_id ? `${union.from.name} [${union.from.instance_id}]` : union.from.name
        );
        const toExists = componentOptions.includes(
          union.to.instance_id ? `${union.to.name} [${union.to.instance_id}]` : union.to.name
        );
        return {
          ...union,
          from: fromExists ? union.from : { name: '', instance_id: '' },
          to: toExists ? union.to : { name: '', instance_id: '' },
        };
      });

      const updatedUnionsForComparison = updatedUnions.map(u => ({
        fromName: u.from.name, fromInstanceId: u.from.instance_id,
        toName: u.to.name, toInstanceId: u.to.instance_id,
        type: u.type,
      }));

      if (JSON.stringify(updatedUnionsForComparison) !== JSON.stringify(currentUnionsForComparison)) {
        onUnionChange(updatedUnions);
      }
    }
  }, [components, componentOptions, unions, onUnionChange, generateInOrder]);

  useEffect(() => {
    if (generateInOrder) {
      let newTargetUnions = [];
      const newErrorsForUnions = [];

      if (components.length >= 2) {
        for (let i = 0; i < components.length - 1; i++) {
          const fromComponent = components[i];
          const toComponent = components[i + 1];
          newTargetUnions.push({
            id: `auto-gen-${fromComponent.name}-${fromComponent.instance_id || 'uid_none'}-to-${toComponent.name}-${toComponent.instance_id || 'uid_none'}`,
            from: { ...fromComponent },
            to: { ...toComponent },
            type: autoGeneratedUnionType
          });
          newErrorsForUnions.push(null);
        }
      }

      let needsUpdate = false;
      if (unions.length !== newTargetUnions.length) {
        needsUpdate = true;
      } else {
        for (let i = 0; i < newTargetUnions.length; i++) {
          if (
            unions[i].id !== newTargetUnions[i].id ||
            unions[i].from.name !== newTargetUnions[i].from.name ||
            unions[i].from.instance_id !== newTargetUnions[i].from.instance_id ||
            unions[i].to.name !== newTargetUnions[i].to.name ||
            unions[i].to.instance_id !== newTargetUnions[i].to.instance_id ||
            unions[i].type !== newTargetUnions[i].type
          ) {
            needsUpdate = true;
            break;
          }
        }
      }

      if (needsUpdate) {
        onUnionChange(newTargetUnions);
        if (setErrors && expressionIndex !== undefined) {
          setErrors((prevErrors) => {
            const currentExpressionErrors = prevErrors[expressionIndex] || {};
            return {
              ...prevErrors,
              [expressionIndex]: { ...currentExpressionErrors, unions: newErrorsForUnions },
            };
          });
        }
      }
    }
  }, [generateInOrder, components, unions, onUnionChange, setErrors, expressionIndex, autoGeneratedUnionType]);

  const handleAddUnion = () => {
    if (generateInOrder) setGenerateInOrder(false);
    const newUnion = {
      id: crypto.randomUUID(),
      from: { name: '', instance_id: '' },
      to: { name: '', instance_id: '' },
      type: '',
    };
    const updatedUnions = [...unions, newUnion];
    onUnionChange(updatedUnions);
    if (setErrors && expressionIndex !== undefined) {
      setErrors((prevErrors) => {
        const updatedExpressionErrors = { ...(prevErrors[expressionIndex] || {}) };
        const currentUnionErrors = Array.isArray(updatedExpressionErrors.unions) ? [...updatedExpressionErrors.unions] : [];
        currentUnionErrors.push(null);
        updatedExpressionErrors.unions = currentUnionErrors;
        return { ...prevErrors, [expressionIndex]: updatedExpressionErrors };
      });
    }
  };

  const handleUnionChange = (unionIndex, field, value) => {
    if (generateInOrder) setGenerateInOrder(false);
    const updatedUnions = [...unions];
    const targetUnion = { ...updatedUnions[unionIndex] };
    if (field === 'from' || field === 'to') {
      const matches = typeof value === 'string' ? value.match(/^(.*)\s\[(\d+)\]$/) : null;
      targetUnion[field] = matches ? { name: matches[1], instance_id: parseInt(matches[2], 10) } : (value ? { name: value, instance_id: '' } : { name: '', instance_id: '' });
    } else if (field === 'type') {
      targetUnion[field] = value || '';
    }
    updatedUnions[unionIndex] = targetUnion;
    onUnionChange(updatedUnions);
  };

  const handleRemoveUnion = (unionId) => {
    if (generateInOrder) setGenerateInOrder(false);
    const unionIndexToRemove = unions.findIndex((union) => union.id === unionId);
    const updatedUnions = unions.filter((union) => union.id !== unionId);
    onUnionChange(updatedUnions);
    if (setErrors && expressionIndex !== undefined && unionIndexToRemove !== -1) {
      setErrors((prevErrors) => {
        const updatedExpressionErrors = { ...(prevErrors[expressionIndex] || {}) };
        if (Array.isArray(updatedExpressionErrors.unions)) {
          const updatedUnionErrors = [...updatedExpressionErrors.unions];
          updatedUnionErrors.splice(unionIndexToRemove, 1);
          updatedExpressionErrors.unions = updatedUnionErrors;
        }
        return { ...prevErrors, [expressionIndex]: updatedExpressionErrors };
      });
    }
  };

  const handleGenerateInOrderChange = (event) => {
    setGenerateInOrder(event.target.checked);
  };

  const handleAutoGeneratedTypeChange = (event, newValue) => {
    if (newValue) {
      setAutoGeneratedUnionType(newValue);
    } else {
      setAutoGeneratedUnionType('Order');
    }
  };

  return (
    <Box>
      <Box sx={{ display: 'flex', flexDirection: 'row', alignItems: 'center', mb: .5 }}>
        <Typography sx={{ mt: 0.5, color: (helperText && typeof helperText === 'string') ? '#d32f2f' : 'primary' }}>Unions</Typography>
        <IconButton onClick={handleAddUnion} color="primary" sx={{ color: (helperText && typeof helperText === 'string') ? '#d32f2f' : 'primary' }} size='small' disabled={generateInOrder}>
          <AddCircleOutlineIcon />
        </IconButton>
      </Box>
      {(helperText && typeof helperText === 'string') && (
        <Typography sx={{ fontSize: '12px', color: '#d32f2f', ml: 0.5, mb: 2 }}>{helperText}</Typography>
      )}
      <Typography sx={{ fontSize: '13px', color: 'primary.main', ml: .5, mb: 1 }}>
        Add the unions for each component (consider all selected components).
      </Typography>

      <Box sx={{ display: 'flex', mb: 2, flexDirection: 'column' }}>
        <FormControlLabel
          control={<Checkbox checked={generateInOrder} onChange={handleGenerateInOrderChange} size="small" sx={{
            '& .MuiSvgIcon-root': {
              color: 'primary.main'
            }, ml: .5
          }} />}
          label={<Typography sx={{ fontSize: '13px', mr: 1, color: 'primary.main' }}>Generate unions automatically by component order</Typography>}
        />
        {generateInOrder && (
          <Autocomplete
            options={unionTypeOptions}
            value={autoGeneratedUnionType}
            onChange={handleAutoGeneratedTypeChange}
            disableClearable
            getOptionLabel={(option) => option}
            isOptionEqualToValue={(option, value) => option === value}
            size="small"
            renderInput={(params) => (
              <TextField {...params} label="Type for auto-generation" sx={{ mt: 2 }} focused />
            )}
            sx={{ ml: generateInOrder ? 0 : 0, mt: generateInOrder ? { xs: 1, sm: 0 } : 0 }}
          />
        )}
      </Box>

      {unions.map((union, unionIndex) => (
        <Box key={union.id || unionIndex} sx={{ border: 0.5, mb: 2, borderRadius: 1, borderColor: 'gray', opacity: generateInOrder ? 0.7 : 1 }}>
          <Box sx={{ p: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Autocomplete
              disabled={generateInOrder}
              options={componentOptions}
              value={union.from.instance_id ? `${union.from.name} [${union.from.instance_id}]` : (union.from.name || '')}
              onChange={(event, newValue) => handleUnionChange(unionIndex, 'from', newValue)}
              getOptionLabel={(option) => typeof option === 'string' ? option : (option.name ? (option.instance_id ? `${option.name} [${option.instance_id}]` : option.name) : '')}
              isOptionEqualToValue={(option, value) => {
                const optVal = typeof option === 'string' ? option : (option.name ? (option.instance_id ? `${option.name} [${option.instance_id}]` : option.name) : '');
                const valVal = typeof value === 'string' ? value : (value.name ? (value.instance_id ? `${value.name} [${value.instance_id}]` : value.name) : '');
                return optVal === valVal;
              }}
              renderInput={(params) => (
                <TextField {...params} label="From" size="small" sx={{ mr: 1 }}
                  error={!generateInOrder && helperText?.[union.id]?.from ? true : false}
                  helperText={!generateInOrder && (helperText?.[union.id]?.from || '')}
                  focused={!generateInOrder && document.activeElement === params.inputProps?.ref?.current}
                />
              )}
            />
            <Autocomplete
              disabled={generateInOrder}
              options={componentOptions}
              value={union.to.instance_id ? `${union.to.name} [${union.to.instance_id}]` : (union.to.name || '')}
              onChange={(event, newValue) => handleUnionChange(unionIndex, 'to', newValue)}
              getOptionLabel={(option) => typeof option === 'string' ? option : (option.name ? (option.instance_id ? `${option.name} [${option.instance_id}]` : option.name) : '')}
              isOptionEqualToValue={(option, value) => {
                const optVal = typeof option === 'string' ? option : (option.name ? (option.instance_id ? `${option.name} [${option.instance_id}]` : option.name) : '');
                const valVal = typeof value === 'string' ? value : (value.name ? (value.instance_id ? `${value.name} [${value.instance_id}]` : value.name) : '');
                return optVal === valVal;
              }}
              renderInput={(params) => (
                <TextField {...params} label="To" size="small" sx={{ mr: 1 }}
                  error={!generateInOrder && helperText?.[union.id]?.to ? true : false}
                  helperText={!generateInOrder && (helperText?.[union.id]?.to || '')}
                  focused={!generateInOrder && document.activeElement === params.inputProps?.ref?.current}
                />
              )}
            />
            <Autocomplete
              disabled={generateInOrder}
              options={unionTypeOptions}
              value={union.type || ''}
              onChange={(event, newValue) => handleUnionChange(unionIndex, 'type', newValue)}
              renderInput={(params) => (
                <TextField {...params} label="Type" size="small"
                  error={!generateInOrder && helperText?.[union.id]?.type ? true : false}
                  helperText={!generateInOrder && (helperText?.[union.id]?.type || '')}
                  focused={!generateInOrder && document.activeElement === params.inputProps?.ref?.current}
                />
              )}
            />
            <Box sx={{ display: 'flex', justifyContent: 'right' }}>
              <IconButton onClick={() => handleRemoveUnion(union.id)} color="primary" disabled={generateInOrder}>
                <DeleteIcon />
              </IconButton>
            </Box>
          </Box>
        </Box>
      ))}
    </Box>
  );
};

export default Union;